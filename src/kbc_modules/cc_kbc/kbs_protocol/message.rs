// Copyright (c) 2022 Alibaba Cloud
//
// SPDX-License-Identifier: Apache-2.0
//

use crate::kbc_modules::cc_kbc::crypto::*;
use anyhow::*;
use serde::{Deserialize, Serialize};

pub const KBS_PROTOCOL_VERSION: &str = "0.1.0";

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Request {
    version: String,
    tee: String,

    // JWT token from KBS.
    token: String,

    // Reserved field.
    #[serde(rename = "extra-params")]
    pub extra_params: String,
}

impl Request {
    pub fn new(token: Option<String>, tee: String) -> Request {
        Request {
            version: KBS_PROTOCOL_VERSION.to_string(),
            tee,
            token: token.unwrap_or_default(),
            extra_params: "".to_string(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Challenge {
    // Nonce from KBS to prevent replay attack.
    pub nonce: String,

    // Reserved field.
    #[serde(rename = "extra-params")]
    pub extra_params: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Evidence {
    // Nonce from KBS to prevent replay attack.
    // Its hash is included in `tee-evidence`.
    pub nonce: String,
    pub tee: String,

    // The public key of TEE.
    // Its hash is included in `tee-evidence`.
    #[serde(rename = "tee-pubkey")]
    pub tee_pubkey: String,

    // TEE quote, different TEE type has different format of the content.
    #[serde(rename = "tee-evidence")]
    pub tee_evidence: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Response {
    // The API output of KBS.
    // It is encrypted and base64 encoded by the random symmetric key generated by KBS.
    output: String,

    // Crypto annotation record the information of the symmetric key to encrypt output.
    #[serde(rename = "crypto-annotation")]
    crypto_annotation: CryptoAnnotation,

    // The token issued by KBS contains the public key of TEE.
    // The token is signed by KBS.
    token: String,
}

impl Response {
    // Use TEE's private key to decrypt output of Response.
    pub fn decrypt_output(&self, tee_key: TeeKey) -> Result<Vec<u8>> {
        let cipher_text =
            base64::decode(&self.output).map_err(|_| anyhow!("KBS output is not base64 code"))?;
        self.crypto_annotation.decrypt(tee_key, cipher_text)
    }

    // Get token from Response
    pub fn token(&self) -> String {
        self.token.clone()
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ErrorDetails {
    pub info: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ErrorResponse {
    pub error: ErrorDetails,
}

impl ErrorResponse {
    pub fn error_info(&self) -> String {
        self.error.info.clone()
    }
}
